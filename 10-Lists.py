########################################################################################################################
#
# № 3 - Создание списков и добавление элементов
#
# src/solution.py
#
# Для успешного прохождения этой практики вам нужно будет реализовать две функции:
# get_square_roots
#
# Эта функция должна принимать число и возвращать список квадратных корней этого числа. Например для аргумента
# 9 функция должна вернуть [-3, 3]. Тест ожидает, что сначала в списке будет идти отрицательный корень, если таковой
# имеется. Также корень может быть и один, если аргумент равен нулю. А ещё корней может и не быть, если аргумент
# отрицательный
#
# >>> get_square_roots(25)
# [-5.0, 5.0]
#
#     Для решения используйте функцию sqrt из модуля math (модуль нужно будет импортировать).
#
# get_range
#
# Данная функция должна для заданного положительного числа аргумента n возвращать список чисел от нуля до n, не включая
# само число n. Если при вызове было передано отрицательное число или ноль, функция должна возвращать пустой список
#
# >>> get_range(5)
# [0, 1, 2, 3, 4]
#
#     Для решения используйте цикл while и метод списка append
#
# SOLUTION:

import math


# BEGIN (write your solution here)


def get_square_roots(number):
    if number < 0:
        return []
    if number == 0:
        return [0]
    return [- math.sqrt(number), math.sqrt(number)]

# END


# BEGIN (write your solution here)


def get_range(number):
    if number == 0 or number < 0:
        return []
    result_range = [0]
    i = 1
    while i < number:
        result_range.append(i)
        i = i + 1
    return result_range

# END

#
########################################################################################################################
#
# № 5 - Ссылки и мутабельность
#
# src/solution.py
#
# Вам необходимо реализовать функцию duplicate, которая должна принимать в качестве аргумента список и удваивать этот
# список "по месту" (вам нужно будет изменять исходный объект списка. Помним: список передаётся по ссылке!)
# Удваивание здесь означает, что после применения к нему функции список должен иметь копию всех элементов, добавленную
# в конец (см. пример ниже)
#
# Пример:
#
# >>> l = [1, 2]
# >>> duplicate(l)  # ничего не возвращается!
# >>> l
# [1, 2, 1, 2]
#
# SOLUTION:

# BEGIN (write your solution here)


def duplicate(lst: list):
    for item in lst[:]:
        lst.append(item)

# END

#
########################################################################################################################
#
# № 6 - Модификация списков поэлементно, сортировка, разворачивание
#
#
# src/solution.py
#
# Вам нужно реализовать функцию rotate, которая должна принимать список в качестве аргумента и делать над ним следующее
# преобразование (список нужно изменять "на месте"!): последний элемент списка должен быть перемещён в начало списка
# (см. пример ниже). Если функция получает пустой список, то изменять его она не должна
#
#     Для решения используйте методы insert и pop
#
# Пример:
#
# >>> l = [1, 2, 3]
# >>> rotate(l)
# >>> l
# [3, 1, 2]
#
# SOLUTION:

# BEGIN (write your solution here)


def rotate(lst):
    if lst != []:
        lst.insert(0, lst.pop(len(lst) - 1))

# END

#
########################################################################################################################
#
# № 7 - Срезы
#
#
# src/solution.py
#
# В этом упражнении вам нужно будет реализовать две функции — rotated_left и rotated_right. Каждая функция должна
# принять список, кортеж или строку в качестве аргумента, с помощью срезов и конкатенации получить новое значение того
# же типа, вернуть это значение
#
# Отличаются функции лишь "направлением поворота" (см. примеры ниже)
#
# Т.к. и строки, и списки с кортежами разрешают конкатенацию и срезы, ваш код не должен проверять тип аргумента — нужно
# обойтись только лишь срезами и конкатенацией!
#
# Обратите внимание: имена функций содержат глагол с окончанием ed — в пайтоне подобным образом часто называют функции,
# возвращающие новое значение на основе старого

# Примеры:
#
# При вращении влево первый элемент перемещается в конец:
#
# >>> rotated_left("ABCD")
# "BCDA"
#
# При вращении вправо последний элемент перемещается в начало:
#
# >>> rotated_right([1, 2, 3, 4])
# [4, 1, 2, 3]
#
# SOLUTION:

# BEGIN


def rotated_right(items):
    return items[-1:] + items[:-1]


def rotated_left(items):
    return items[1:] + items[:1]

# END

#
########################################################################################################################
