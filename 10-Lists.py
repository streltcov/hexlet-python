########################################################################################################################
#
# № 3 - Создание списков и добавление элементов
#
# src/solution.py
#
# Для успешного прохождения этой практики вам нужно будет реализовать две функции:
# get_square_roots
#
# Эта функция должна принимать число и возвращать список квадратных корней этого числа. Например для аргумента
# 9 функция должна вернуть [-3, 3]. Тест ожидает, что сначала в списке будет идти отрицательный корень, если таковой
# имеется. Также корень может быть и один, если аргумент равен нулю. А ещё корней может и не быть, если аргумент
# отрицательный
#
# >>> get_square_roots(25)
# [-5.0, 5.0]
#
#     Для решения используйте функцию sqrt из модуля math (модуль нужно будет импортировать).
#
# get_range
#
# Данная функция должна для заданного положительного числа аргумента n возвращать список чисел от нуля до n, не включая
# само число n. Если при вызове было передано отрицательное число или ноль, функция должна возвращать пустой список
#
# >>> get_range(5)
# [0, 1, 2, 3, 4]
#
#     Для решения используйте цикл while и метод списка append
#
# SOLUTION:

import math


# BEGIN (write your solution here)


def get_square_roots(number):
    if number < 0:
        return []
    if number == 0:
        return [0]
    return [- math.sqrt(number), math.sqrt(number)]

# END


# BEGIN (write your solution here)


def get_range(number):
    if number == 0 or number < 0:
        return []
    result_range = [0]
    i = 1
    while i < number:
        result_range.append(i)
        i = i + 1
    return result_range

# END

#
########################################################################################################################
#
# № 5 - Ссылки и мутабельность
#
# src/solution.py
#
# Вам необходимо реализовать функцию duplicate, которая должна принимать в качестве аргумента список и удваивать этот
# список "по месту" (вам нужно будет изменять исходный объект списка. Помним: список передаётся по ссылке!)
# Удваивание здесь означает, что после применения к нему функции список должен иметь копию всех элементов, добавленную
# в конец (см. пример ниже)
#
# Пример:
#
# >>> l = [1, 2]
# >>> duplicate(l)  # ничего не возвращается!
# >>> l
# [1, 2, 1, 2]
#
# SOLUTION:

# BEGIN (write your solution here)


def duplicate(lst: list):
    for item in lst[:]:
        lst.append(item)

# END

#
########################################################################################################################
#
# № 6 - Модификация списков поэлементно, сортировка, разворачивание
#
#
# src/solution.py
#
# Вам нужно реализовать функцию rotate, которая должна принимать список в качестве аргумента и делать над ним следующее
# преобразование (список нужно изменять "на месте"!): последний элемент списка должен быть перемещён в начало списка
# (см. пример ниже). Если функция получает пустой список, то изменять его она не должна
#
#     Для решения используйте методы insert и pop
#
# Пример:
#
# >>> l = [1, 2, 3]
# >>> rotate(l)
# >>> l
# [3, 1, 2]
#
# SOLUTION:

# BEGIN (write your solution here)


def rotate(lst):
    if lst != []:
        lst.insert(0, lst.pop(len(lst) - 1))

# END

#
########################################################################################################################
#
# № 7 - Срезы
#
#
# src/solution.py
#
# В этом упражнении вам нужно будет реализовать две функции — rotated_left и rotated_right. Каждая функция должна
# принять список, кортеж или строку в качестве аргумента, с помощью срезов и конкатенации получить новое значение того
# же типа, вернуть это значение
#
# Отличаются функции лишь "направлением поворота" (см. примеры ниже)
#
# Т.к. и строки, и списки с кортежами разрешают конкатенацию и срезы, ваш код не должен проверять тип аргумента — нужно
# обойтись только лишь срезами и конкатенацией!
#
# Обратите внимание: имена функций содержат глагол с окончанием ed — в пайтоне подобным образом часто называют функции,
# возвращающие новое значение на основе старого

# Примеры:
#
# При вращении влево первый элемент перемещается в конец:
#
# >>> rotated_left("ABCD")
# "BCDA"
#
# При вращении вправо последний элемент перемещается в начало:
#
# >>> rotated_right([1, 2, 3, 4])
# [4, 1, 2, 3]
#
# SOLUTION:

# BEGIN


def rotated_right(items):
    return items[-1:] + items[:-1]


def rotated_left(items):
    return items[1:] + items[:1]

# END

#
########################################################################################################################
#
# № 8 - Цикл for
#
# src/solution.py
#
# В этом упражнении вы будете реализовывать классический цикл поиска. Функция find_index, которую вам предстоит
# написать, должна принимать значение и нечто, по чему можно итерироваться — строку, список, кортеж. В ответ функция
# должна вернуть индекс первого элемента итерируемой последовательности, равного заданному значению. Если же значение в
# последовательности не встречается или же последовательность окажется пустой, функция должна вернуть None
#
# >>> find_index('t', 'cat')
# 2
# >>> find_index(5, [1, 2, 3, 4, 5, 6, 7])
# 4
# >>> find_index(42, []) is None
# True
# >>> find_index('!', 'abc') is None
# True
#
#     При выполнении воспользуйтесь циклом for и функцией enumerate
#
# SOLUTION:

# BEGIN (write your solution here)


def find_index(needle, collection):
    for index, item in enumerate(collection):
        if item == needle:
            return index
    return None

# END

#
########################################################################################################################
#
# № 9 - Итераторы
#
# src/solution.py
#
# Цель данного упражнения — реализовать функцию find_second_index. В этом упражнении вам пригодится функция find_index,
# которую вы реализовали в прошлом упражнении. Напоминаю, эта функция возвращает индекс первого элемента
# последовательности, равного заданному значению. Функция find_second_index же должна возвращать индекс
# второго подходящего элемента в последовательности. Если подходящих элементов в последовательности меньше двух
# или же последовательность пуста, нужно всё так же возвращать None
#
# >>> find_second_index('b', 'bob')
# 2
# >>> find_second_index('a', 'cat') is None
# True
#
# Новую функцию вам следует реализовывать с помощью уже имеющейся find_index. И не забудьте, что итератор сохраняет
# позицию, в которой остановился обход — это знание поможет вам в решении поставленной задачи!
#
# SOLUTION:


def find_index(value, items):
    for index, item in enumerate(items):
        if item == value:
            return index
    return None


# BEGIN (write your solution here)


def find_second_index(value, items):
    cursor = iter(items)
    first_index = find_index(value, cursor)
    if first_index is not None:
        second_index = find_index(value, cursor)
        if second_index is not None:
            return second_index + first_index + 1
    return None

# END

#
########################################################################################################################
