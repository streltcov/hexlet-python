########################################################################################################################
#
# № 2 - Синтаксис
#
# src/solution.py
#
# В этой практике вам нужно реализовать две функции:
#
#     функцию make_user, которая должна принимать два параметра — имя пользователя и возраст (число). Вернуть функция
#     должна словарь с ключами 'name' и 'age', по которым должны быть сохранены соответствующие значения
#     функцию format_user, которая, будучи применена к результату вызова make_user (помним — это словарь), должна
#     вернуть строку вида 'Phil, 25'
#
# Пример:
#
# >>> phil = make_user('Phil', 25)
# >>> type(phil)
# <class 'dict'>
# >>> format_user(phil)
# 'Phil, 25'
#
# SOLUTION:

# BEGIN (write your solution here)


def make_user(name, age):
    return {'name': name, 'age': age}


def format_user(user):
    return str(user.get('name')) + ', ' + str(user.get('age'))

# END

#
########################################################################################################################
#
# № 3 - Изменение данных в словаре
#
# src/solution.py
#
# Цель упражнения — функция count_all. Эта функция должна принимать на вход iterable источник и возвращать словарь,
# ключами которого являются элементы источника, а значения отражают количество повторов элемента в коллекции-источнике
# Вот пара примеров, демонстрирующих то, как функция должна работать:
#
# >>> count_all(["cat", "dog", "cat"])
# {"cat": 2, "dog": 1}
# >>> count_all("hello")
# {'h': 1, 'e': 1, 'l': 2, 'o': 1}
# >>> count_all("*" * 20)
# {'*': 20}
#
# SOLUTION:

# BEGIN (write your solution here)


def count_all(items):
    result = {}
    for item in items:
        if item not in result:
            result[item] = 1
        else:
            result[item] = result[item] + 1
    return result

# END

#
########################################################################################################################
#
# № 4 - Инициализация новых значений и defaultdics
#
# src/solution.py
#
# Цель упражнения — функция collect_indexes. Эта функция должна принимать на вход коллекцию (некий iterator/iterable)
# и возвращать словарь (или подобная ему коллекция!), где ключом будет элемент коллекции, а значением для ключа
# — список индексов коллекции, по которым встречается этот элемент
# Пример
#
# >>> d = collect_indexes("hello")
# >>> d["h"]
# [0]
# >>> d["e"]
# [1]
# >>> d["l"]
# [2, 3]
#
# SOLUTION:

# BEGIN (write your solution here)

# Rev. v.1


def collect_indexes(items):
    result = {}
    for index, item in enumerate(items):
        if item in result:
            result[item].append(index)
        else:
            result[item] = [index]
    return result

# END

# Rev v.2


# BEGIN (write your solution here)

from collections import defaultdict


def collect_indexes(items):
    result = defaultdict(list)
    for index, item in enumerate(items):
        result[item].append(index)
    return result

# END

#
########################################################################################################################
#
# № 5 - Множества
#
# src/solution.py
#
# Вам предстоит реализовать функцию all_unique, которая должна принимать итератор (в т.ч. и те, которые не
# перезапускаемые!) и возвращать True, если элементы в итераторе не повторяются (если элементов нет, то ничего не
# повторяется!). Пример работы функции:
#
# >>> all_unique("cat")
# True
# >>> all_unique([1, 2, 3])
# True
# >>> all_unique([1, 2, 1])
# False
#
# SOLUTION:

# BEGIN (write your solution here)


def all_unique(items):
    check_items = []
    for item in items:
        check_items.append(item)
    return len(check_items) == len(set(check_items))

# END

#
########################################################################################################################
#
# № 6 - Изменение множеств
#
# src/solution.py
#
# В этой практике вы будете реализовывать функции для работы с множествами, как с наборами флагов.
#
# Флаги удобны для управления работой некоторого кода: если флаг поднят, значит какая-то возможность включена. В
# этом плане флаги похожи на галочки в формах и бланках — галочку тоже можно поставить или не поставить
#
# В нашем случае флаги будут представлять собой элементы множества: если элемент в множестве присутствует, значит
# и флаг поднят. Вам же нужно будет реализовать две функции: toggle и toggled
#
# Функция toggle
#
# Эта функция должна принимать флаг и множество в качестве аргументов. Если флаг уже присутствует в множестве, его
# нужно из множества убрать. Если же флаг отсутствует, то его нужно добавить. Таким образом функция будет переключать
# состояние флага. Множество нужно заменять "по месту", возвращать из функции ничего не нужно. Пример использования
# функции toggle:
#
# >>> READ_ONLY = 'read_only'
# >>> flags = set()
# >>> toggle(READ_ONLY, flags)
# >>> READ_ONLY in flags
# True
# >>> toggle(READ_ONLY, flags)
# >>> READ_ONLY in flags
# False
#
# Функция toggled
#
# Эта функция работает похожим на toggle образом, но вместо изменения исходного множества возвращает новое — с уже
# переключенным флагом. Пример:
#
# >>> READ_ONLY = 'read_only'
# >>> flags = set()
# >>> new_flags = toggled(READ_ONLY, flags)
# >>> READ_ONLY in flags
# False
# >>> READ_ONLY in new_flags
# True
#
# SOLUTION:

# BEGIN (write your solution here)


def toggle(flag, items):
    if flag in items:
        items.discard(flag)
    else:
        items.add(flag)


def toggled(flag, items):
    new_set = set(items)
    if flag not in new_set:
        new_set.add(flag)
    else:
        new_set.discard(flag)
    return new_set

# END

#
########################################################################################################################
#
# № 7 - Операции над множествами
#
# src/solution.py
#
# В этом упражнении вам предстоит анализировать изменения, имея старую и новую версии словаря. Требуется реализовать
# функцию diff_keys, которая должна принимать два словаря-аргумента — "старый" и "новый" — и возвращать словарь
# с результатами анализа. Результирующий словарь должен содержать строго три ниже перечисленных ключа:
#
#     'kept' — множество ключей, которые присутствовали в старом словаре и остались в новом;
#     'added' — множество ключей, которые отсутствовали в старом словаре, но появились в новом;
#     'removed' — множество ключей, которые присутствовали в старом словаре, но в новый не вошли.
#
# Пример
#
# >>> diff_keys({'name': 'Bob', 'age': 42}, {})
# {'kept': set(), 'added': set(), 'removed': {'name', 'age'}}
# >>> diff_keys({}, {'name': 'Bob', 'age': 42})
# {'kept': set(), 'added': {'name', 'age'}, 'removed': set()}
# >>> diff_keys({'a': 2}, {'a': 1})
# {'kept': {'a'}, 'added': set(), 'removed': set()}
#
#     Заметьте, значения не сравниваются — только ключи!
#
# SOLUTION:

# BEGIN (write your solution here)


def diff_keys(old_dict, new_dict):
    return {
        'kept': set(old_dict) & set(new_dict),
        'added': set(new_dict) - set(old_dict),
        'removed': set(old_dict) - set(new_dict),
    }

# END

#
########################################################################################################################
#
# № 8 - Методы объектов множеств
#
# src/solution.py
#
# Цель упражнения — функция apply_diff. Эта функция принимает два аргумента, первым из которых выступает множество,
# которое нужно будет изменять "по месту" (возвращать ничего не нужно). Вторым аргументом функция принимает словарь,
# который может содержать ключи 'add' и 'remove' с множествами в качестве значений. Значения по ключу 'add' нужно
# добавить в изменяемое множество, а значения по ключу 'remove' — убрать из множества. Прочие ключи в переданном
# словаре значения не имеют и обрабатываться не должны
# Пример
#
# >>> target = {'a', 'b'}
# >>> diff = {'add': {'c'}, 'remove': {'a'}}
# >>> apply_diff(target, diff)
# >>> target
# {'c', 'b'}
#
# Подсказка
#
# Не используйте методы add и discard. В этом упражнении нужено манипулировать множествами "целиком"
#
# SOLUTION:

# BEGIN (write your solution here)


def apply_diff(target, diff):
    for key in set(diff):
        if key == 'add':
            for item in diff[key]:
                target.add(item)
        elif key == 'remove':
            for item in diff[key]:
                target.discard(item)

# END

#
########################################################################################################################
